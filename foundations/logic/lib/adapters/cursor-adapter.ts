/**
 * Monol Rulebook - Cursor Adapter
 *
 * .cursorrules íŒŒì¼ ë™ê¸°í™” ì–´ëŒ‘í„°
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import type { Rule } from '../types.js';
import {
  BasePlatformAdapter,
  rulesToDirectives,
  rulesToMarkdownDocument,
  registerAdapter,
} from './platform-adapter.js';

// ============================================================================
// Cursor Adapter
// ============================================================================

export class CursorAdapter extends BasePlatformAdapter {
  name = 'cursor';
  private outputFile = '.cursorrules';

  protected getOutputPath(): string {
    return path.join(this.basePath, this.outputFile);
  }

  async read(): Promise<string> {
    try {
      return await fs.readFile(this.getOutputPath(), 'utf-8');
    } catch {
      return '';
    }
  }

  format(rules: Rule[]): string {
    // Cursorì—ì„œ í™œì„±í™”ëœ ê·œì¹™ë§Œ í•„í„°ë§
    const cursorRules = rules.filter(r =>
      r.enabled !== false &&
      (r.platforms?.cursor?.enabled !== false || !r.platforms)
    );

    // í¬í•¨ ì—¬ë¶€ í•„í„°ë§
    const includeRules = cursorRules.filter(r =>
      r.platforms?.cursor?.includeInRules !== false
    );

    const lines: string[] = [];

    // í—¤ë”
    lines.push('# Project Rules');
    lines.push('');
    lines.push('> Auto-generated by Monol Rulebook');
    lines.push(`> Last updated: ${new Date().toISOString()}`);
    lines.push('');

    // ê·œì¹™ ìš”ì•½
    lines.push('## Overview');
    lines.push('');
    lines.push(`Total rules: ${includeRules.length}`);
    lines.push('');

    // ì¹´í…Œê³ ë¦¬ë³„ ê·¸ë£¹í™”
    const byCategory = new Map<string, Rule[]>();
    for (const rule of includeRules) {
      const category = rule.category.split('/')[0];
      if (!byCategory.has(category)) {
        byCategory.set(category, []);
      }
      byCategory.get(category)!.push(rule);
    }

    // ê·œì¹™ ì¶œë ¥
    for (const [category, catRules] of byCategory) {
      lines.push(`## ${this.capitalizeFirst(category)} Rules`);
      lines.push('');

      for (const rule of catRules) {
        lines.push(this.formatRule(rule));
        lines.push('');
      }
    }

    // í‘¸í„°
    lines.push('---');
    lines.push('');
    lines.push('For more details, run `/rule <id>` in Claude Code');

    return lines.join('\n');
  }

  async write(content: string): Promise<void> {
    await this.ensureDir(this.getOutputPath());
    await fs.writeFile(this.getOutputPath(), content, 'utf-8');
  }

  private formatRule(rule: Rule): string {
    const lines: string[] = [];

    // ê·œì¹™ í—¤ë”
    const severityEmoji = rule.severity === 'error' ? 'ğŸ”´' :
                          rule.severity === 'warning' ? 'ğŸŸ¡' : 'ğŸ”µ';
    lines.push(`### ${severityEmoji} ${rule.name}`);
    lines.push('');

    // ì„¤ëª…
    lines.push(rule.description.trim());
    lines.push('');

    // ì˜ˆì‹œ
    if (rule.examples) {
      if (rule.examples.good && rule.examples.good.length > 0) {
        lines.push('**Do:**');
        lines.push('```');
        for (const example of rule.examples.good) {
          lines.push(example.trim());
        }
        lines.push('```');
        lines.push('');
      }

      if (rule.examples.bad && rule.examples.bad.length > 0) {
        lines.push("**Don't:**");
        lines.push('```');
        for (const example of rule.examples.bad) {
          lines.push(example.trim());
        }
        lines.push('```');
        lines.push('');
      }
    }

    // ì˜ˆì™¸
    if (rule.exceptions && rule.exceptions.length > 0) {
      lines.push('**Exceptions:**');
      for (const exception of rule.exceptions) {
        lines.push(`- ${exception}`);
      }
      lines.push('');
    }

    return lines.join('\n');
  }

  private capitalizeFirst(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}

// ì–´ëŒ‘í„° ë“±ë¡
registerAdapter('cursor', CursorAdapter);

export default CursorAdapter;
